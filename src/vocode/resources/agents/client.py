# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...errors.unprocessable_entity_error import UnprocessableEntityError
from ...types.agent import Agent
from ...types.agent_page import AgentPage
from ...types.agent_update_params import AgentUpdateParams
from ...types.http_validation_error import HttpValidationError
from ...types.interrupt_sensitivity import InterruptSensitivity
from ...types.language import Language
from .types.agent_params_actions_item import AgentParamsActionsItem
from .types.agent_params_endpointing_sensitivity import AgentParamsEndpointingSensitivity
from .types.agent_params_ivr_navigation_mode import AgentParamsIvrNavigationMode
from .types.agent_params_openai_account_connection import AgentParamsOpenaiAccountConnection
from .types.agent_params_prompt import AgentParamsPrompt
from .types.agent_params_vector_database import AgentParamsVectorDatabase
from .types.agent_params_voice import AgentParamsVoice
from .types.agent_params_webhook import AgentParamsWebhook

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AgentsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_agent(self, *, id: str) -> Agent:
        """
        Parameters:
            - id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/agents"),
            params=remove_none_from_dict({"id": id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Agent, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_agents(self, *, page: typing.Optional[int] = None, size: typing.Optional[int] = None) -> AgentPage:
        """
        Parameters:
            - page: typing.Optional[int].

            - size: typing.Optional[int].
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/agents/list"),
            params=remove_none_from_dict({"page": page, "size": size}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentPage, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_agent(
        self,
        *,
        prompt: AgentParamsPrompt,
        language: typing.Optional[Language] = OMIT,
        actions: typing.Optional[typing.List[AgentParamsActionsItem]] = OMIT,
        voice: AgentParamsVoice,
        initial_message: typing.Optional[str] = OMIT,
        webhook: typing.Optional[AgentParamsWebhook] = OMIT,
        vector_database: typing.Optional[AgentParamsVectorDatabase] = OMIT,
        interrupt_sensitivity: typing.Optional[InterruptSensitivity] = OMIT,
        context_endpoint: typing.Optional[str] = OMIT,
        noise_suppression: typing.Optional[bool] = OMIT,
        endpointing_sensitivity: typing.Optional[AgentParamsEndpointingSensitivity] = OMIT,
        ivr_navigation_mode: typing.Optional[AgentParamsIvrNavigationMode] = OMIT,
        conversation_speed: typing.Optional[float] = OMIT,
        initial_message_delay: typing.Optional[float] = OMIT,
        openai_model_name_override: typing.Optional[str] = OMIT,
        ask_if_human_present_on_idle: typing.Optional[bool] = OMIT,
        openai_account_connection: typing.Optional[AgentParamsOpenaiAccountConnection] = OMIT,
        run_do_not_call_detection: typing.Optional[bool] = OMIT,
    ) -> Agent:
        """
        Parameters:
            - prompt: AgentParamsPrompt.

            - language: typing.Optional[Language].

            - actions: typing.Optional[typing.List[AgentParamsActionsItem]].

            - voice: AgentParamsVoice.

            - initial_message: typing.Optional[str].

            - webhook: typing.Optional[AgentParamsWebhook].

            - vector_database: typing.Optional[AgentParamsVectorDatabase].

            - interrupt_sensitivity: typing.Optional[InterruptSensitivity].

            - context_endpoint: typing.Optional[str].

            - noise_suppression: typing.Optional[bool].

            - endpointing_sensitivity: typing.Optional[AgentParamsEndpointingSensitivity].

            - ivr_navigation_mode: typing.Optional[AgentParamsIvrNavigationMode].

            - conversation_speed: typing.Optional[float].

            - initial_message_delay: typing.Optional[float].

            - openai_model_name_override: typing.Optional[str].

            - ask_if_human_present_on_idle: typing.Optional[bool].

            - openai_account_connection: typing.Optional[AgentParamsOpenaiAccountConnection].

            - run_do_not_call_detection: typing.Optional[bool].
        """
        _request: typing.Dict[str, typing.Any] = {"prompt": prompt, "voice": voice}
        if language is not OMIT:
            _request["language"] = language
        if actions is not OMIT:
            _request["actions"] = actions
        if initial_message is not OMIT:
            _request["initial_message"] = initial_message
        if webhook is not OMIT:
            _request["webhook"] = webhook
        if vector_database is not OMIT:
            _request["vector_database"] = vector_database
        if interrupt_sensitivity is not OMIT:
            _request["interrupt_sensitivity"] = interrupt_sensitivity
        if context_endpoint is not OMIT:
            _request["context_endpoint"] = context_endpoint
        if noise_suppression is not OMIT:
            _request["noise_suppression"] = noise_suppression
        if endpointing_sensitivity is not OMIT:
            _request["endpointing_sensitivity"] = endpointing_sensitivity
        if ivr_navigation_mode is not OMIT:
            _request["ivr_navigation_mode"] = ivr_navigation_mode
        if conversation_speed is not OMIT:
            _request["conversation_speed"] = conversation_speed
        if initial_message_delay is not OMIT:
            _request["initial_message_delay"] = initial_message_delay
        if openai_model_name_override is not OMIT:
            _request["openai_model_name_override"] = openai_model_name_override
        if ask_if_human_present_on_idle is not OMIT:
            _request["ask_if_human_present_on_idle"] = ask_if_human_present_on_idle
        if openai_account_connection is not OMIT:
            _request["openai_account_connection"] = openai_account_connection
        if run_do_not_call_detection is not OMIT:
            _request["run_do_not_call_detection"] = run_do_not_call_detection
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/agents/create"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Agent, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_agent(self, *, id: str, request: AgentUpdateParams) -> Agent:
        """
        Parameters:
            - id: str.

            - request: AgentUpdateParams.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/agents/update"),
            params=remove_none_from_dict({"id": id}),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Agent, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncAgentsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_agent(self, *, id: str) -> Agent:
        """
        Parameters:
            - id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/agents"),
            params=remove_none_from_dict({"id": id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Agent, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_agents(self, *, page: typing.Optional[int] = None, size: typing.Optional[int] = None) -> AgentPage:
        """
        Parameters:
            - page: typing.Optional[int].

            - size: typing.Optional[int].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/agents/list"),
            params=remove_none_from_dict({"page": page, "size": size}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AgentPage, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_agent(
        self,
        *,
        prompt: AgentParamsPrompt,
        language: typing.Optional[Language] = OMIT,
        actions: typing.Optional[typing.List[AgentParamsActionsItem]] = OMIT,
        voice: AgentParamsVoice,
        initial_message: typing.Optional[str] = OMIT,
        webhook: typing.Optional[AgentParamsWebhook] = OMIT,
        vector_database: typing.Optional[AgentParamsVectorDatabase] = OMIT,
        interrupt_sensitivity: typing.Optional[InterruptSensitivity] = OMIT,
        context_endpoint: typing.Optional[str] = OMIT,
        noise_suppression: typing.Optional[bool] = OMIT,
        endpointing_sensitivity: typing.Optional[AgentParamsEndpointingSensitivity] = OMIT,
        ivr_navigation_mode: typing.Optional[AgentParamsIvrNavigationMode] = OMIT,
        conversation_speed: typing.Optional[float] = OMIT,
        initial_message_delay: typing.Optional[float] = OMIT,
        openai_model_name_override: typing.Optional[str] = OMIT,
        ask_if_human_present_on_idle: typing.Optional[bool] = OMIT,
        openai_account_connection: typing.Optional[AgentParamsOpenaiAccountConnection] = OMIT,
        run_do_not_call_detection: typing.Optional[bool] = OMIT,
    ) -> Agent:
        """
        Parameters:
            - prompt: AgentParamsPrompt.

            - language: typing.Optional[Language].

            - actions: typing.Optional[typing.List[AgentParamsActionsItem]].

            - voice: AgentParamsVoice.

            - initial_message: typing.Optional[str].

            - webhook: typing.Optional[AgentParamsWebhook].

            - vector_database: typing.Optional[AgentParamsVectorDatabase].

            - interrupt_sensitivity: typing.Optional[InterruptSensitivity].

            - context_endpoint: typing.Optional[str].

            - noise_suppression: typing.Optional[bool].

            - endpointing_sensitivity: typing.Optional[AgentParamsEndpointingSensitivity].

            - ivr_navigation_mode: typing.Optional[AgentParamsIvrNavigationMode].

            - conversation_speed: typing.Optional[float].

            - initial_message_delay: typing.Optional[float].

            - openai_model_name_override: typing.Optional[str].

            - ask_if_human_present_on_idle: typing.Optional[bool].

            - openai_account_connection: typing.Optional[AgentParamsOpenaiAccountConnection].

            - run_do_not_call_detection: typing.Optional[bool].
        """
        _request: typing.Dict[str, typing.Any] = {"prompt": prompt, "voice": voice}
        if language is not OMIT:
            _request["language"] = language
        if actions is not OMIT:
            _request["actions"] = actions
        if initial_message is not OMIT:
            _request["initial_message"] = initial_message
        if webhook is not OMIT:
            _request["webhook"] = webhook
        if vector_database is not OMIT:
            _request["vector_database"] = vector_database
        if interrupt_sensitivity is not OMIT:
            _request["interrupt_sensitivity"] = interrupt_sensitivity
        if context_endpoint is not OMIT:
            _request["context_endpoint"] = context_endpoint
        if noise_suppression is not OMIT:
            _request["noise_suppression"] = noise_suppression
        if endpointing_sensitivity is not OMIT:
            _request["endpointing_sensitivity"] = endpointing_sensitivity
        if ivr_navigation_mode is not OMIT:
            _request["ivr_navigation_mode"] = ivr_navigation_mode
        if conversation_speed is not OMIT:
            _request["conversation_speed"] = conversation_speed
        if initial_message_delay is not OMIT:
            _request["initial_message_delay"] = initial_message_delay
        if openai_model_name_override is not OMIT:
            _request["openai_model_name_override"] = openai_model_name_override
        if ask_if_human_present_on_idle is not OMIT:
            _request["ask_if_human_present_on_idle"] = ask_if_human_present_on_idle
        if openai_account_connection is not OMIT:
            _request["openai_account_connection"] = openai_account_connection
        if run_do_not_call_detection is not OMIT:
            _request["run_do_not_call_detection"] = run_do_not_call_detection
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/agents/create"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Agent, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_agent(self, *, id: str, request: AgentUpdateParams) -> Agent:
        """
        Parameters:
            - id: str.

            - request: AgentUpdateParams.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/agents/update"),
            params=remove_none_from_dict({"id": id}),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Agent, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
